---
title: Python Penetration Testing (Pentest)
date: 2022-09-13 06:47:42
tags:
---

# Chapter 1: Python with Penetration Testing and Networking
## Phạm vi của pentesting
Nói đơn giản, thì pentest được sử dục cho việc đánh giá bảo mật thông tin của một công ty, một tổ chức. Bao gồm: mạng, website, cơ sở dữ liệu, máy chủ public-facing, chính sách bảo mật và mọi thứ khác do khách hàng chỉ định. Vào mỗi ngày, pentester phải trình bày báo cáo chi tiết về những phát hiện như điểm yếu, lỗ hỏng trong cơ sở hạ tầng của công ty và mức độ rủi ro của các lỗ hổng cụ thể - cung cấp giải pháp nếu có thể.
### Cần thiết cho pentesting

Có một số điểm mô tả ý nghĩa của việc pentest:
- Pentest xác định những mỗi đe dọa có thể phơi bày bảo mật của một tổ chức
- Chuyên gia pentesting đảm bảo cho tổ chức với đánh giá đầy đủ và chi tiết
- Pentesting đánh giá hiệu quả của mạng bằng cách tạo một lượng lớn truy cập
- Thay đổi hoặc nâng cấp cơ sở hạ tầng đang tồn tại của hardware, software hoặc network design có thể sẽ dẫn tới lỗ hổng - có thể phát hiện bởi pentesting
- Thế giới ngày nay, các mối đe dọa tiềm năng đang giảm đáng kể; pentesting là một proactive execise để giảm thiểu cơ hội bị lợi dụng
- Pentesting đảm bảo liệu các chính sách bảo mật phù hợp có đang được tuân thủ hay không

Một tổ chức nên tiến hành một hoạt động đánh giá rủi ro trước khi pentest.

Có thể sử dụng những tool trên chợ, có thể tự tạo tool nhờ kiến thức lập trình - Chọn python.

### Định nghĩa phạm vi của pentesting

- You should develop the scope of the project by consulting with the client. For example, if Bob (the client) wants to test the entire network infrastructure of the organization, then pentester Alice would define the scope of pentesting by taking this network into account. Alice will consult Bob on whether any sensitive or restricted areas should be included or not.

- You should take into account time, people, and money.

- You should profile the test boundaries on the basis of an agreement signed by the pentester and the client.

- Changes in business practice might affect the scope. For example, the addition of a subnet, new system component installations, the addition or modification of a web server, and so on, might change the scope of pentesting.

2 loại pentesting:
- A non-destructive test: 
    - Tìm kiếm lỗ hổng tiềm ẩn - quét và xác định hệ thống từ xa
    - Điều tra và xác minh phát hiện
    - Khai thác thích hợp, lập bản đồ lỗ hổng
    - Khai thác hệ thống từ xa 1 cách cẩn thận
    - Cung cấp bằng chứng về khái niệm
    - Không cố gắng tấn công DoS
- A destructive test: 
    - Cố gắng tấn công DoS và tràn bộ nhớ đệm - có thể gây hỏng bộ nhớ

### Các cách tiếp cận để pentesting:

Có 3 cách tiếp cận để pentesting:
- Black-box pentesting:
    - Chỉ được cung cấp tên công ty
    - Như là hacking với kiến thức của một attacker bên ngoài
    - Bạn không cần biết trước bất kì một kiến thức nào của hệ thống
    - Tiêu tốn thời gian
- White-box pentesting:
    - Bạn sẽ được cung cấp kiến thức hoàn chỉnh của cơ sở hạ tầng cần test
    - Giống như một nhân viên xấu có kiến thức phong phú về cơ sở hạ tầng của công ty
    - Được cung cấp thông tin trên cơ sở hạ tầng của công ty, network type, chính sách, được làm và không, địa chỉ IP, và IPS/IDS firewall
- Gray-box pentesting:
    - Tester thường có thông tin hạn chế về mạng / hệ thống mục tiêu được khách hàng cung cấp để giảm chi phí và giảm thử nghiệm - sai sót trên một phần của tầng áp dụng
    - Nó thực hiện đánh giá bảo mật và kiểm tra nội bộ
## Network Sockets

Một địa chỉ network socket bao gồm địa chỉ IP và Port. Một cách đơn giản, một socket là một cách để nói chuyện với một máy tính kahsc. Bằng việc định nghĩa một socket, một quá trình có thể giao tiếp với một quá trình khác trong mạng.

Để tạo một socket, sử dụng socket.socket():
```py
s = socket.socket (socket_family, socket_type, protocol=0)
```
Đây là mô tả của parameters:
```python
socket_family: socket.AF_INET, PF_PACKET
```
AF_INET là địa chỉ IPv4, PF_PACKET hoạt động ở driver layer thiết bị. Thư viện pcap cho Linux sử dụng PF_PACKET.

```python
Socket_type : socket.SOCK_DGRAM, socket.SOCK_RAW,socket.SOCK_STREAM
```

- socket.bind(address)
- socket.listen(q)
- socket.accept()
- socket.recv(bufsize)
- socket.recvfrom(bufsize)
- socket.recv_into(buffer)
- socket.recvfrom_into(buffer)
- socket.send(bytes)
- socket.sendto(data, address)
- socket.sendall(data)

### Moving on to the practical

Trước tiên, tạo một chương trình server-side cung cấp một kết nối tới khách hàng và gửi một tin nhắn tới khách hàng. Chạy server1.py:
```python
import socket
host = 'localhost' #Server address
port = 12345  #Port of Server
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((host,port)) #bind server 
s.listen(2) 
conn, addr = s.accept()  
print(addr, 'Now Connected')
conn.send('Thank you for connecting'.encode())
conn.close()
```
Explain:
First, import the socket module and define the host and port number, 192.168.0.1 is the server's IP address. Socket.AF_INET defines the IPv4 protocol's family. Socket.SOCK_STREAM defines the TCP connection. The s.bind((host,port)) statement takes only one argument. It binds the socket to the host and port number. The s.listen(2) statement listens to the connection and waits for the client. The conn, addr = s.accept() statement returns two values: conn and addr. The conn socket is the client socket, as we discussed earlier. The conn.send() function sends the message to the client. Finally, conn.close() closes the socket. From the following examples and screenshot, you will understand conn better.

client1.py:
```python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = 'localhost'  # server address
port = 12345  #server port 
s.connect((host,port)) 
print(s.recv(1024))
s.send('Hello Server'.encode())
s.close()
```

Sử dụng vòng lặp while để tạo server không bị tắt, 1 server có thể gửi cho nhiều client - o, server2.py:
```python
import socket 
host = 'localhost'
port = 12345
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((host,port))
s.listen(2)
while True:
  conn, addr = s.accept()
  print(addr, 'Now Connected')
  conn.send('Thank you for connecting'.encode())
  conn.close()
```

Limit số lần truy cập:
```python
import socket 

current_conn = 0
limit_conn = 10
host = 'localhost'
port = 12345
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((host,port))
s.listen(2)
while current_conn < limit_conn:
  current_conn += 1
  conn, addr = s.accept()
  print(addr, 'Now Connected')
  conn.send('Thank you for connecting'.encode())
  conn.close()
```

#### Sử dụng bytearray() và s.recv_into(buff)

Run server3.py:
```python
import socket

host = 'localhost'
port = 12345
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((host, port))
s.listen(1)
conn, addr = s.accept()
print('Connected by', addr)
conn.send('Thanks'.encode())
conn.close()
```
Server sẽ gửi 'Thanks', 6 kí tự.
Run client3.py:
```python
import socket

host = 'localhost'
port = 12345
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host, port))
buf = bytearray('-'.encode() * 30) # Buffer created
print('Number of bytes', s.recv_into(buf))
print(buf)
s.close()
```

socket.SOCK_DGRAM creates a UDP socket

Run udp1.py:
```python
import socket

host = 'localhost'
port = 12346
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind((host, port))
data, addr = s.recvfrom(1024)
print('Received from ', addr)
print('Obtained ', data)

s.close()
```
Run udp2.py:
```python
import socket

host = 'localhost'
port = 12346
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
print(s.sendto('Hello mhuyyy!'.encode(), (host, port)))
s.close
```
s.settimeout(5) - Sau 5s không có kết nối thì tự đóng kết nối
#### Socket exception
Sử dụng try catch except với settimeout:
```python
import socket
host = 'localhost'
port = 12346
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
try:
  
  s.bind((host,port))
  s.settimeout(5)
  data, addr = s.recvfrom(1024)
  print('recevied from ',addr)
  print('obtained ', data)
  s.close()
  
except socket.timeout :
  print('Client not connected')
  s.close()
```
Sau 5 giây không kết nối, server sẽ trả về dòng chữ Client not connected

Thư viện python còn hỗ trợ nhiều exception socket khác:
- exception socket.herror: This block catches the address-related error.
- exception socket.timeout: This block catches the exception when a timeout on a socket occurs, which has been - enabled by settimeout(). In the previous example, you can see that we used socket.timeout.
- exception socket.gaierror: This block catches any exception that is raised due to getaddrinfo() and getnameinfo().
- exception socket.error: This block catches any socket-related errors. If you are not sure about any - exception, you could use this. In other words, you can say that it is a generic block and can catch any type of exception.
#### Userful socket methods

```python
import socket

socket.gethostbyname('facebook.com') # '31.13.75.35'
socket.gethostbyname_ex('facebook.com') # ('facebook.com', [], ['31.13.75.35'])
socket.gethostname() # 'TaMinhHuy'
socket.gethostbyname(socket.gethostname()) # Get your pc IP '26.36.128.153'
socket.gethostbyname_ex(socket.gethostname()) # ('TaMinhHuy', [], ['192.168.255.1', '192.168.43.1', '172.22.80.1', '26.36.128.153', '192.168.88.106'])
socket.getfqdn('facebook.com') # 'edge-star-mini-shv-02-hkt1.facebook.com' - Fully quailified domain name (FQDN)
# ...
```

socket.connect_ex(address): Trả ra error indicator. Nếu thành công, nó trả ra 0; Còn khoongm nó trả ra biến errno. Bạn có thể dùng nó để scan port. Chạy connect_ex.py:
```python
import socket

rmip ='localhost'
portlist = [22,23,80,912,135,445,20]

for port in portlist:
	sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	result = sock.connect_ex((rmip,port))
	print(port,':', result)
	sock.close()
```

Kết quả:
```bash
22 : 10061
23 : 10061
80 : 0
912 : 0
135 : 0
445 : 0
20 : 10061
```
Port 80, 912, 135, 445 đang được mở

socket.getaddrinfo method:
```bash
>>> socket.getaddrinfo('www.facebook.com', 'http')
[(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 0, '', ('31.13.75.35', 80))]
>>>
```
# Chapter 2: Scanning Pentesting

## How to check live systems in a network and the concept of a live system

### Ping sweep

Ping sweep được sử dụng để định danh máy chủ live từ phạm vi của địa chỉ IP bằng việc gửi ICMP ECHO request và ICMP ECHO reply. Từ subnet và địa chỉ mạng, một attacker hoặc pentester có thể tính toán phạm vi mạng. Ở section này, tôi sẽ trình bày cách tận dụng ping của hệ điều hành


Từ đó chúng ta có thể viết một chương trình kiểm tra 1 loạt địa chỉ IP liền kề nhau có đang LIVE hay không:
```python
import os
import platform
from datetime import datetime

net = input()

net1 = net.split('.')
a = '.'
net2 = net1[0] + a + net1[1] + a + net1[2] + a

print(net2)
st1 = int(input('Enter the Starting Number: '))
en1 = int(input('Enter the End Number: '))

en1 = en1 + 1

oper = platform.system()

if(oper == 'Windows'):
    ping1 = 'ping -n 1 '
elif(oper == 'Linux'):
    ping1 = 'ping -c 1 '
else:
    ping1 = 'ping -c 1 '

t1 = datetime.now()

print('Scanning in Progress...')
for ip in range(st1, en1):
    addr = net2 + str(ip)
    comm = ping1 + addr

    response = os.popen(comm)

    for line in response.readlines():
        if 'ttl' in line.lower():
            break
        if 'ttl' in line.lower():
            print(addr, '--> Live')

t2 = datetime.now()
total = t2 - t1
print("Scanning complete in ", total)
```

Nhưng ping_sweep.py chạy quá chậm, tiêu tốn quá nhiều thời gian. Python cung cấp cho bạn "multithreading", nó sẽ làm cho chương trình của bạn nhanh hơn:

```python
import os
import collections
import platform
import socket, subprocess,sys
import threading
from datetime import datetime
''' section 1 '''

net = raw_input('Enter the Network Address ')
net1= net.split('.')
a = '.'
net2 = net1[0]+a+net1[1]+a+net1[2]+a
st1 = int(raw_input('Enter the Starting Number '))
en1 = int(raw_input('Enter the Last Number '))
en1 =en1+1
dic = collections.OrderedDict()
oper = platform.system()

if (oper=='Windows'):
  ping1 = 'ping -n 1 '
elif (oper== 'Linux'):
  ping1 = 'ping -c 1 '
else :
  ping1 = 'ping -c 1 '
t1= datetime.now()
'''section 2'''
class myThread (threading.Thread):
  def __init__(self,st,en):
    threading.Thread.__init__(self)
    self.st = st
    self.en = en
  def run(self):
    run1(self.st,self.en)
'''section 3'''         
def run1(st1,en1):
  #print 'Scanning in Progess'
  for ip in xrange(st1,en1):
    #print '.',
    addr = net2+str(ip)
    comm = ping1+addr
    response = os.popen(comm)
    for line in response.readlines():
      if(line.count('TTL')):
        break
    if (line.count('TTL')):
      #print addr, '--> Live'
      dic[ip]= addr
''' Section 4  '''
total_ip =en1-st1
tn =20  # number of ip handled by one thread
total_thread = total_ip/tn
total_thread=total_thread+1
threads= []
try:
  for i in xrange(total_thread):
    en = st1+tn
    if(en >en1):
      en =en1
    thread = myThread(st1,en)
    thread.start()
    threads.append(thread)
    st1 =en
except:
  print 'Error: unable to start thread'
print 't
Number of Threads active:', threading.activeCount()

for t in threads:
  t.join()
print 'Exiting Main Thread'
dict = collections.OrderedDict(sorted(dic.items()))
for key in dict:
  print dict[key],'-->' 'Live'
t2= datetime.now()
total =t2-t1
print 'scanning complete in ' , total
```
# Chapter 3: Sniffing and Penetration Testing

## Introducing a network sniffer

### Passive sniffing

### Active sniffing

## Implementing a network sniffer using Python

struct method:
- struct.pack(fmt, v1, v2, ...): Trả ra một chuỗi bao gồm v1, v2, được đóng gói theo định dạng đã cho
- struct.unpack(fmt, string): Giải nén chuỗi theo định dạng đã cho

```python
import struct
ms = struct.pack('hhl', 1, 2, 3)
print(ms)
k = struct.unpack('hhl', ms)
print(k)
```
More info: https://docs.python.org/3/library/struct.html

# Chapter 4: Introducing ARP spoofing and implementing it using Python

ARP (Address Resolution Protocol) - chuyển đổi IP thành Ethernet tương ứng. Khi một packet đến Network layer(OSI), nó có địa chỉ IP và data-link layer packet cần địa chỉ MAC của thiết bị đích. Trong trường hợp này, người gửi sử dụng ARP.

- The ARP request
- The ARP reply

# Chapter 5: Tesing the security system using custom packet crafting

Ở chapter 2,  Scanning pentesting, bạn đã thấy port scanner, làm việc dựa trên TCP connect scan. Three-way handshake là khái niệm cơ bản của TCP connect scan.

## A Half-open scan

Kĩ thuật này được sử dụng để vượt qua các quy tắc tường lửa và tránh bị phát hiện bởi hệ thống ghi nhật ký.

Sử dụng thư viện scapy - giúp tạo custom-made packets.

Các bước:

1. The client sends a SYN packet to the server on the intended port
2. If the port is open, then the server responds with the SYN/ACK packet
3. If the server responds with an RST packet, it means the port is closed
4. The client sends the RST to close the initiation

```python
from scapy.all import *
ip1 = IP(src='192.168.0.10', dst ='192.168.0.3' )
tcp1 = TCP(sport =1024, dport=80, flags='S', seq=12345)
packet = ip1/tcp1
p =sr1(packet, inter=1)
p.show()

rs1 = TCP(sport =1024, dport=80, flags='R', seq=12347)
packet1=ip1/rs1
p1 = sr1(packet1)
p1.show()
```




